# Internationalization (i18n) Guide

This document covers internationalization with i18next and react-i18next.

## Table of Contents

- [Overview](#overview)
- [Setup](#setup)
- [Project Structure](#project-structure)
- [Adding Translations](#adding-translations)
- [Using Translations](#using-translations)
- [Language Detection](#language-detection)
- [Changing Language](#changing-language)
- [Best Practices](#best-practices)
- [Testing](#testing)
- [Troubleshooting](#troubleshooting)

## Overview

### Why i18next?

- **Industry Standard**: Most popular i18n framework for JavaScript
- **React Native Support**: First-class support via react-i18next
- **Type Safety**: Full TypeScript support
- **Feature Rich**: Pluralization, interpolation, formatting, and more
- **Performance**: Efficient bundle splitting and lazy loading

### Current Languages

- English (en) - Default
- Spanish (es)

### Tech Stack

- **i18next**: Core i18n framework
- **react-i18next**: React bindings for i18next
- **react-native-localize**: Device locale detection

## Setup

The project is already configured with i18next. This section documents the setup for reference.

### Dependencies

```json
{
  "dependencies": {
    "i18next": "^25.6.0",
    "react-i18next": "^16.2.4",
    "react-native-localize": "^3.6.0"
  }
}
```

### Configuration

**`src/i18n/index.ts`:**

```typescript
import { initReactI18next } from 'react-i18next';
import { getLocales } from 'react-native-localize';
import i18next from 'i18next';

import { resources } from './resources';

export const defaultNS = 'translation';

const languageTag = resolveLanguageTag({ getLocales });

i18next.use(initReactI18next).init({
  compatibilityJSON: 'v4',
  lng: languageTag,
  fallbackLng: 'en',
  defaultNS,
  resources,
  interpolation: {
    escapeValue: false, // React already escapes
  },
});

export default i18next;
```

**`src/i18n/resources.ts`:**

```typescript
import en from './locales/en.json';
import es from './locales/es.json';

/**
 * Translation resources for all supported languages
 */
export const resources = {
  en: { translation: en },
  es: { translation: es },
} as const;
```

### Language Detection

**`src/i18n/index.ts`:**

```typescript
export interface LocalizeModule {
  getLocales?: () => Array<{
    languageTag: string;
    languageCode?: string;
  }>;
}

const fallback = { languageTag: 'en', isRTL: false };

export const resolveLanguageTag = (localize: LocalizeModule): string => {
  const supported = Object.keys(resources);
  const locales = localize.getLocales?.() ?? [];
  const primary = locales[0];

  if (primary) {
    const { languageTag, languageCode } = primary;

    // 1) Exact tag match (e.g. "en", "es")
    if (languageTag && supported.includes(languageTag)) {
      return languageTag;
    }

    // 2) Base language match (e.g. "es-ES" -> "es")
    if (languageCode) {
      const baseMatch = supported.find(code => code === languageCode);
      if (baseMatch) {
        return baseMatch;
      }
    }
  }

  // 3) Fallback to English if nothing matches
  return fallback.languageTag;
};
```

This ensures the app uses:

1. Device language if supported
2. Base language if device uses regional variant (e.g., "es-MX" → "es")
3. English as fallback

## Project Structure

```
src/i18n/
├── __tests__/
│   ├── index.test.ts           # i18n initialization tests
│   └── localesParity.test.ts   # Translation completeness tests
├── locales/
│   ├── en.json                 # English translations
│   └── es.json                 # Spanish translations
├── index.ts                    # i18next configuration
└── resources.ts                # Translation resource imports
```

### Translation Files

**`src/i18n/locales/en.json`:**

```json
{
  "home": {
    "title": "Home",
    "env": "ENV",
    "apiUrl": "API_URL",
    "settings": "Settings"
  },
  "settings": {
    "title": "Settings",
    "language": "Language",
    "preferredLanguage": "Preferred Language",
    "appearance": "Appearance",
    "darkAppearance": "Dark Appearance",
    "general": "General"
  },
  "language": {
    "title": "Language",
    "languages": "Languages",
    "english": "English",
    "spanish": "Spanish"
  },
  "appearance": {
    "title": "Appearance",
    "appearance": "Appearance",
    "automatic": "Automatic",
    "light": "Light",
    "dark": "Dark"
  }
}
```

## Adding Translations

### 1. Add New Translation Keys

Edit both `en.json` and `es.json`:

**`src/i18n/locales/en.json`:**

```json
{
  "profile": {
    "title": "Profile",
    "editProfile": "Edit Profile",
    "logout": "Logout",
    "greeting": "Hello, {{name}}!",
    "itemCount": "You have {{count}} item",
    "itemCount_plural": "You have {{count}} items"
  }
}
```

**`src/i18n/locales/es.json`:**

```json
{
  "profile": {
    "title": "Perfil",
    "editProfile": "Editar Perfil",
    "logout": "Cerrar Sesión",
    "greeting": "¡Hola, {{name}}!",
    "itemCount": "Tienes {{count}} artículo",
    "itemCount_plural": "Tienes {{count}} artículos"
  }
}
```

### 2. Run Parity Test

Ensure all languages have the same keys:

```bash
yarn test localesParity
```

This test validates that:

- All languages have identical key structures
- No missing translations
- No extra keys in any language

**`src/i18n/__tests__/localesParity.test.ts`:**

```typescript
import { resources } from '../resources';

describe('Locales Parity', () => {
  const languages = Object.keys(resources);
  const [baseLanguage, ...otherLanguages] = languages;
  const baseKeys = getKeys(resources[baseLanguage].translation);

  otherLanguages.forEach(language => {
    it(`${language} has all keys from ${baseLanguage}`, () => {
      const languageKeys = getKeys(resources[language].translation);
      expect(languageKeys).toEqual(baseKeys);
    });
  });
});

function getKeys(obj: any, prefix = ''): string[] {
  return Object.keys(obj).reduce((keys: string[], key) => {
    const path = prefix ? `${prefix}.${key}` : key;
    if (typeof obj[key] === 'object') {
      return [...keys, ...getKeys(obj[key], path)];
    }
    return [...keys, path];
  }, []);
}
```

### 3. Organize by Feature

Structure translations to mirror your feature structure:

```json
{
  "home": {
    "title": "Home",
    "welcome": "Welcome"
  },
  "settings": {
    "title": "Settings",
    "language": "Language"
  },
  "auth": {
    "login": "Login",
    "signup": "Sign Up",
    "email": "Email",
    "password": "Password"
  }
}
```

### 4. Nested Keys

Use dot notation for nested keys:

```json
{
  "errors": {
    "network": {
      "timeout": "Connection timeout",
      "offline": "No internet connection"
    },
    "validation": {
      "required": "This field is required",
      "email": "Invalid email address"
    }
  }
}
```

Access with: `t('errors.network.timeout')`

## Using Translations

### In Components

**Basic Usage:**

```typescript
import { useTranslation } from 'react-i18next';

export const HomeScreen = () => {
  const { t } = useTranslation();

  return (
    <View>
      <Text>{t('home.title')}</Text>
      <Button>{t('home.settings')}</Button>
    </View>
  );
};
```

**With Interpolation:**

```typescript
const { t } = useTranslation();

// Translation: "Hello, {{name}}!"
<Text>{t('profile.greeting', { name: 'John' })}</Text>
// Output: "Hello, John!"
```

**With Pluralization:**

```typescript
const { t } = useTranslation();

// count: 1
<Text>{t('profile.itemCount', { count: 1 })}</Text>
// Output: "You have 1 item"

// count: 5
<Text>{t('profile.itemCount', { count: 5 })}</Text>
// Output: "You have 5 items"
```

**With Default Value:**

```typescript
// Fallback if key doesn't exist
<Text>{t('missing.key', 'Default Text')}</Text>
```

### In Non-React Code

```typescript
import i18next from '@app/i18n';

// Outside React components
const message = i18next.t('errors.network.timeout');
```

### Type-Safe Translations

Create a type helper for autocomplete:

**`src/i18n/types.ts`:**

```typescript
import { resources } from './resources';

type Translation = typeof resources.en.translation;

type RecursiveKeyOf<TObj extends object> = {
  [TKey in keyof TObj & (string | number)]: TObj[TKey] extends object
    ? `${TKey}` | `${TKey}.${RecursiveKeyOf<TObj[TKey]>}`
    : `${TKey}`;
}[keyof TObj & (string | number)];

export type TranslationKey = RecursiveKeyOf<Translation>;
```

**Usage:**

```typescript
import type { TranslationKey } from '@app/i18n/types';

const key: TranslationKey = 'home.title'; // ✓ Valid
const invalid: TranslationKey = 'home.invalid'; // ✗ TypeScript error
```

### Access Current Language

```typescript
import { useTranslation } from 'react-i18next';

const { i18n } = useTranslation();

console.log(i18n.language); // "en" or "es"
```

## Language Detection

### Device Language on App Start

The app automatically detects device language:

```typescript
// src/i18n/index.ts
import { getLocales } from 'react-native-localize';

const languageTag = resolveLanguageTag({ getLocales });
```

**Device Settings:**

- Device set to Spanish → App shows Spanish
- Device set to English → App shows English
- Device set to French → App shows English (fallback)
- Device set to "es-MX" → App shows Spanish (base language match)

### Override in Redux

User preference stored in Redux overrides device language:

```typescript
// src/features/Settings/store/reducer.ts
export interface SettingsState {
  theme: Theme;
  language: Language; // User's preference
}
```

**Priority:**

1. User preference (from Redux)
2. Device language (from react-native-localize)
3. Fallback (English)

## Changing Language

### In Settings Screen

**`src/features/Language/LanguageScreen.tsx`:**

```typescript
import { useTranslation } from 'react-i18next';
import { useAppDispatch, useAppSelector } from '@app/store/hooks';
import { settingsSliceActions } from '@app/features/Settings/store';
import { selectLanguage } from '@app/features/Settings/store/selectors';

export const LanguageScreen = () => {
  const { t, i18n } = useTranslation();
  const dispatch = useAppDispatch();
  const currentLanguage = useAppSelector(selectLanguage);

  const changeLanguage = async (language: Language) => {
    // Update Redux state (persisted)
    dispatch(settingsSliceActions.setLanguage(language));

    // Change i18next language
    await i18n.changeLanguage(language);
  };

  return (
    <View>
      <Button
        onPress={() => changeLanguage('en')}
        variant={currentLanguage === 'en' ? 'primary' : 'secondary'}
      >
        {t('language.english')}
      </Button>
      <Button
        onPress={() => changeLanguage('es')}
        variant={currentLanguage === 'es' ? 'primary' : 'secondary'}
      >
        {t('language.spanish')}
      </Button>
    </View>
  );
};
```

### Sync Redux with i18next

**`src/app/App.tsx`:**

```typescript
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useAppSelector } from '@app/store/hooks';
import { selectLanguage } from '@app/features/Settings/store/selectors';

export const App = () => {
  const { i18n } = useTranslation();
  const language = useAppSelector(selectLanguage);

  // Sync Redux language to i18next on app start
  useEffect(() => {
    if (language && i18n.language !== language) {
      i18n.changeLanguage(language);
    }
  }, [language, i18n]);

  return <RootNavigator />;
};
```

## Best Practices

### 1. Organize Translations by Feature

```json
{
  "featureName": {
    "key": "value"
  }
}
```

Matches your feature-first architecture.

### 2. Use Descriptive Keys

**Bad:**

```json
{
  "btn1": "Submit",
  "text1": "Hello"
}
```

**Good:**

```json
{
  "auth": {
    "submitButton": "Submit",
    "welcomeMessage": "Hello"
  }
}
```

### 3. Keep Values Concise

Translations are for text content, not documentation:

**Bad:**

```json
{
  "helpText": "This is a very long help text that explains exactly how to use this feature in great detail..."
}
```

**Good:**

```json
{
  "helpText": "Tap to start",
  "helpTextExtended": "Extended help available in Help Center"
}
```

### 4. Use Interpolation for Dynamic Content

**Bad:**

```json
{
  "welcomeJohn": "Welcome, John!",
  "welcomeJane": "Welcome, Jane!"
}
```

**Good:**

```json
{
  "welcome": "Welcome, {{name}}!"
}
```

### 5. Handle Pluralization

**Bad:**

```typescript
const text = count === 1 ? 'You have 1 item' : `You have ${count} items`;
```

**Good:**

```json
{
  "itemCount": "You have {{count}} item",
  "itemCount_plural": "You have {{count}} items"
}
```

```typescript
const text = t('itemCount', { count });
```

### 6. Don't Translate Code

Keep technical terms, brand names, and code untranslated:

```json
{
  "en": {
    "error": "API error occurred"
  },
  "es": {
    "error": "Error de API ocurrió"
  }
}
```

API stays as "API", not "Interfaz de Programación de Aplicaciones"

### 7. Consider Context

Some words translate differently based on context:

```json
{
  "general": {
    "close": "Close"
  },
  "modal": {
    "close": "Close"
  },
  "app": {
    "close": "Exit"
  }
}
```

"Close" (a window) vs "Close" (exit app) may need different translations.

### 8. Maintain Translation Parity

Always update all language files when adding new keys:

```bash
# Run after adding translations
yarn test localesParity
```

### 9. Use Comments for Context

```json
{
  // Used in Settings > Appearance screen
  "appearance": {
    "title": "Appearance",
    // Options for theme selection
    "automatic": "Automatic",
    "light": "Light",
    "dark": "Dark"
  }
}
```

**Note:** JSON doesn't support comments. Use a separate `translations.config.js` file or add a `_comments` key:

```json
{
  "appearance": {
    "_comment": "Used in Settings > Appearance screen",
    "title": "Appearance"
  }
}
```

### 10. Extract Repeated Translations

**Bad:**

```json
{
  "home": {
    "cancel": "Cancel"
  },
  "settings": {
    "cancel": "Cancel"
  },
  "profile": {
    "cancel": "Cancel"
  }
}
```

**Good:**

```json
{
  "common": {
    "cancel": "Cancel",
    "save": "Save",
    "delete": "Delete"
  },
  "home": {
    "title": "Home"
  }
}
```

## Testing

### Test Language Switching

```typescript
import { renderWithProviders } from '@app/test-utils';
import { LanguageScreen } from '../LanguageScreen';

describe('LanguageScreen', () => {
  it('changes language when button pressed', async () => {
    const { getByText, store } = renderWithProviders(<LanguageScreen />);

    // Initially English
    expect(store.getState().settings.language).toBe('en');

    // Switch to Spanish
    fireEvent.press(getByText('Spanish'));

    await waitFor(() => {
      expect(store.getState().settings.language).toBe('es');
    });
  });
});
```

### Test Translations

```typescript
import { renderWithProviders } from '@app/test-utils';
import i18next from '@app/i18n';

describe('HomeScreen translations', () => {
  it('displays Spanish text when language is Spanish', async () => {
    // Change language
    await i18next.changeLanguage('es');

    const { getByText } = renderWithProviders(<HomeScreen />);

    expect(getByText('Inicio')).toBeTruthy(); // "Home" in Spanish
  });
});
```

### Test Interpolation

```typescript
it('interpolates name correctly', () => {
  const { getByText } = renderWithProviders(
    <Greeting name="John" />
  );

  expect(getByText('Hello, John!')).toBeTruthy();
});
```

### Test Pluralization

```typescript
it('shows correct plural form', () => {
  const { rerender, getByText } = renderWithProviders(
    <ItemCount count={1} />
  );

  expect(getByText('You have 1 item')).toBeTruthy();

  rerender(<ItemCount count={5} />);
  expect(getByText('You have 5 items')).toBeTruthy();
});
```

## Troubleshooting

### Translations Not Updating

**Problem**: Changed translations don't appear in app

**Solution**:

```bash
# Clear Metro cache
yarn start --reset-cache

# Reload app
# iOS: Cmd+R in simulator
# Android: RR in terminal or Cmd+M > Reload
```

### Missing Translation Warning

**Problem**: `i18next: key not found: "some.key"`

**Solution**:

1. Verify key exists in all language files
2. Check for typos
3. Run parity test:

```bash
yarn test localesParity
```

### Wrong Language on Start

**Problem**: App doesn't use device language

**Solution**:

1. Check `resolveLanguageTag` logic
2. Verify language is supported:

```typescript
const supported = Object.keys(resources);
console.log('Supported languages:', supported);
```

3. Check device language:

```typescript
import { getLocales } from 'react-native-localize';

console.log('Device locales:', getLocales());
```

### Language Doesn't Persist

**Problem**: Language resets after app restart

**Solution**:

1. Verify Redux Persist is configured:

```typescript
// src/store/configureStore.ts
const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['settings'], // Must include 'settings'
};
```

2. Check if language is saved to Redux:

```typescript
import { selectLanguage } from '@app/features/Settings/store/selectors';

const language = useAppSelector(selectLanguage);
console.log('Saved language:', language);
```

### Pluralization Not Working

**Problem**: Plural forms not showing correctly

**Solution**:

1. Ensure keys follow i18next convention:

```json
{
  "key": "singular form",
  "key_plural": "plural form"
}
```

2. Pass `count` parameter:

```typescript
t('key', { count: 5 });
```

3. Check `compatibilityJSON` setting:

```typescript
i18next.init({
  compatibilityJSON: 'v4', // Required for React Native
});
```

## Adding a New Language

### 1. Create Translation File

**`src/i18n/locales/fr.json`:**

```json
{
  "home": {
    "title": "Accueil",
    "settings": "Paramètres"
  }
}
```

### 2. Import in resources.ts

```typescript
import en from './locales/en.json';
import es from './locales/es.json';
import fr from './locales/fr.json';

export const resources = {
  en: { translation: en },
  es: { translation: es },
  fr: { translation: fr },
} as const;
```

### 3. Add to TypeScript Type

```typescript
// src/features/Settings/store/reducer.ts
export type Language = 'en' | 'es' | 'fr';
```

### 4. Update Language Selector

```typescript
// src/features/Language/LanguageScreen.tsx
<Button onPress={() => changeLanguage('fr')}>
  {t('language.french')}
</Button>
```

### 5. Test Parity

```bash
yarn test localesParity
```

## Next Steps

- See [State Management](./STATE_MANAGEMENT.md) for Redux integration
- See [Testing](./TESTING.md) for testing translations
- See [Contributing](./CONTRIBUTING.md) for translation guidelines
